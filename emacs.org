* Emacs Org

*TIPS*:
 - Use <C-c '> to eval the source block
 - Use =M-x package-refresh-contents= to refresh the package list
 - <l + TAB: opens a latex block
 - <s + TAB: opens a source code block
 - <q + TAB: opens a quotation block

* Configuration
*** Initialization
**** Personal infon
	 Setting email and full name
#+BEGIN_SRC emacs-lisp
(setq user-full-name "M. Vinicius Junqueira"
      user-mail-address "codejunq@gmail.com")
#+END_SRC
**** Loading path and dirs
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp")  ;;  all things lisp
(add-to-list 'load-path "~/.emacs.d/lisp/code") ;; all things code
(add-to-list 'load-path "~/.emacs.d/lisp/misc") ;; misc things
(add-to-list 'load-path "~/.emacs.d/lisp/misc/use-package") ;; for use package
(require 'use-package)
(require 'eieio) ;; because of a bug in helm-dash
#+END_SRC

**** Package System
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
			 '("melpa" . "http://melpa.milkbox.net/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(setq package-enable-at-startup nil)
(package-initialize)
#+END_SRC

*** General Configuration
**** Backup
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files t ;; yep for backup
		backup-by-copying t ;;  backup though copying
		backup-directory-alist '(("." . "~/.backup/emacs")) ;; backup directory
		version-control t
		kept-new-versions 2
		kept-old-versions 4
		delete-old-versions -1
		vc-make-backup-files t)

  ;; PACKAGE: saveplace: save places inside files/buffers
  (setq save-place-file "~/.emacs.d/lisp/data/saveplace")
  (setq-default save-place t)
  (setq auto-save-interval 500)
#+END_SRC

**** Font lock
#+begin_src emacs-lisp
  (global-font-lock-mode 1) ;font lock everywhere
#+end_src

**** History
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/backup/savehist")
(savehist-mode 1)
(setq history-length 10)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
	  '(kill-ring
		search-ring
		regexp-search-ring))
#+END_SRC
**** Helm - the new ido
#+BEGIN_SRC emacs-lisp

;; PACKAGE: semantic-mode
;; loading semantic for helm-semantic-imenu (amazing with c code)
(semantic-mode 1)
(add-to-list 'load-path "~/.emacs.d/elpa/helm")
(add-to-list 'load-path "~/.emacs.d/lisp/helm/emacs-async")

;; PACKAGE: helm-mode and helm-config
(require 'helm-mode)
(require 'helm-config)
;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-unset-key (kbd "C-x c"))
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

(when (executable-find "curl")
  (setq helm-google-suggest-use-curl-p t))
(setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
	  helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	  helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	  helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	  helm-ff-file-name-history-use-recentf t)
(setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x
(setq helm-buffers-fuzzy-matching t
	  helm-recentf-fuzzy-match    t)

(helm-autoresize-mode t)

;; [#keybidings]
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
(global-set-key (kbd "C-c h x") 'helm-register)
(global-set-key (kbd "C-c h g") 'helm-google-suggest)
(global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
(global-set-key (kbd "C-c h o") 'helm-occur)

(add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

;;; fuzzy matching is pretty cool
(setq helm-apropos-fuzzy-match t)
(setq helm-semantic-fuzzy-match t
	  helm-imenu-fuzzy-match    t)
(setq helm-locate-fuzzy-match t)
(setq helm-lisp-fuzzy-completion t)

;; helm-eshell
(require 'helm-eshell)
(add-hook 'eshell-mode-hook
		  #'(lambda ()
			  (define-key eshell-mode-map (kbd "C-c C-l")  'helm-eshell-history)))
(define-key shell-mode-map (kbd "C-c C-l") 'helm-comint-input-ring)
(define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)

;;
;; PACKAGE: helm-swoop
;;
;; super 'occur mode'
;(require 'helm-swoop)

;(global-set-key (kbd "C-c h o") 'helm-swoop)
;(global-set-key (kbd "C-c s") 'helm-multi-swoop-all)
;; When doing isearch, hand the wornd over the heml swoop
;(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)

;; from helm-swoop to heml multi swoop all (d)
;(define-key helm-swoop-map (kbd "M-i") 'heml-multi-swoop-all-from-hel-swoop)

;; save buffer when helm-multi-swoop-edit coimpelte
;(setq heml-multi-swoop-edit-save t)

;; if this value is t, split window inside the current window
;(setq helm-swoop-split-with-multiple-windows t)

;; split direction 'split-window-vertically or split-window horizontally
;(setq helm-swoop-split-direction 'split-window-vertically)

;; if nil, you can slightly boost invoke speed in exchange for text color
;(setq helm-swoop-speed-or-color t)

;(helm-mode 1)

#+END_SRC
**** Gtags
 #+BEGIN_SRC emacs-lisp
(setq
 helm-gtags-ignore-case t
 helm-gtags-auto-update t
 helm-gtags-use-input-at-cursor t
 helm-gtags-pulse-at-cursor t
 helm-gtags-pulse-at-cursor t
 helm-gtags-prefix-key "\C-c g"
 helm-gtags-suggested-key-mapping t
 )

(require 'helm-gtags)
;; enable helm-gtags in various modes
(add-hook 'dired-mode-hook 'helm-gtags-mode)
(add-hook 'eshell-mode-hook 'helm-gtags-mode)
(add-hook 'c-mode-hook 'helm-gtags-mode)
(add-hook 'c++-mode-hook 'helm-gtags-mode)
(add-hook 'asm-mode-hook 'helm-gtags-mode)

;; [#keybinding]
(define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
(define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
(define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwin)
(define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
(define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
(define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)

#+END_SRC
****** TODO colocar o imenu-or-semantic dentro de um atalho melhor
**** Linum - line numbers
#+BEGIN_SRC emacs-lisp
;; PACKAGE: linum-mode
;; numeração de linhas inteligentes
(global-linum-mode t)
;; turning off in org-mode because it's really, really slow
(add-hook 'org-mode-hook (lambda () (linum-mode 0)))
#+END_SRC
**** Winner Mode - frame navigation

#+BEGIN_SRC emacs-lisp
;; PACKAGE: winner mode
;; windows history by C-c left (undo) or C-c right (redo)
(use-package winner
   :ensure winner
   :init (winner-mode 1))
#+END_SRC

**** Modeline
#+BEGIN_SRC emacs-lisp

;; things to show in the modeline
(show-paren-mode 1)
(global-visual-line-mode 1)
(display-time)
(display-battery-mode 1)

(size-indication-mode 1)
(column-number-mode 1)
(line-number-mode 1)

;; PACKAGE: powerline.el
;; powering the mode line with spacemacs theme
(add-to-list 'load-path "~/.emacs.d/lisp/spaceline")
(require 'spaceline-config)
(spaceline-spacemacs-theme)
;(require 'powerline)
;(powerline-vim-theme)
#+END_SRC

**** Recentf: remember last visited files
#+BEGIN_SRC emacs-lisp
;; PACKAGE: recentf
(require 'recentf)
(setq recentf-max-saved-items 200
	  recentf-max-menu-items 15)
;;(global-set-key "\C-c\ \C-r" 'recentf-open-files) ;; BINDING-KEY
(recentf-mode)
#+END_SRC

**** Aliases
#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer)
(defalias 'yes-or-no-p 'y-or-n-p)
(defalias 'qrr 'query-replace-regexp)
(defalias 'evb 'eval-buffer)
(defalias 'evr 'eval-region)
#+END_SRC

**** Buffer Editing

#+BEGIN_SRC emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'capitalize-region 'disabled nil)
(setq x-select-enable-clipboard t) ;; clipboard on
(setq interprogram-past-function 'x-cut-buffer-or-selection-value)
(setq echo-keystrokes 0.1)

;; ibuffer everywhere
(global-set-key (kbd "C-x C-b") 'ibuffer)
(setq ibuffer-use-other-window t) ;; always display ibuffer in another window


(add-hook 'ibuffer-hook
	  (lambda ()
		(ibuffer-vc-set-filter-groups-by-vc-root)
		(unless (eq ibuffer-sorting-mode 'alphabetic)
		  (ibuffer-do-sort-by-alphabetic))))

(setq ibuffer-formats
	  '((mark modified read-only vc-status-mini " "
		  (name 18 18 :left :elide)
		  " "
		  (size 9 -1 :right)
		  " "
		  (mode 16 16 :left :elide)
		  " "
		  (vc-status 16 16 :left)
		  " "
		  filename-and-process)))

#+END_SRC

**** Shell pop
#+BEGIN_SRC emacs-lisp
;; PACKAGE: shell-pop.el
;; terminal popup (:

(setq multi-term-program "/bin/zsh")
(add-hook 'term-mode-hook
		  (lambda ()
			(setq term-buffer-maximum-size 10000)))
(add-hook 'term-mode-hook
		  (lambda ()
			(setq show-trailing-whitespace nil)
			))

(autoload 'multi-term "multi-term" nil t)
(autoload 'multi-term-next "multi-term" nil t)
(defcustom term-unbind-key-list
  '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
  "The key list that will need to be unbind."
  :type 'list
  :group 'multi-term)
(defcustom term-bind-key-alist
  '(
	("C-c C-c" . term-interrupt-subjob)
	("C-p" . previous-line)
	("C-n" . next-line)
	("C-s" . isearch-forward)
	("C-r" . isearch-backward)
	("C-m" . term-send-raw)
	("M-f" . term-send-forward-word)
	("M-b" . term-send-backward-word)
	("M-o" . term-send-backspace)
	("M-p" . term-send-up)
	("M-n" . term-send-down)
	("M-M" . term-send-forward-kill-word)
	("M-N" . term-send-backward-kill-word)
	("M-r" . term-send-reverse-search-history)
	("M-," . term-send-input)
	("M-." . comint-dynamic-complete))
  "The key alist that will need to be bind.
If you do not like default setup, modify it, with (KEY . COMMAND) format."
  :type 'alist
  :group 'multi-term)

(add-hook 'term-mode-hook
		  (lambda ()
			(define-key term-raw-map (kbd "C-y") 'term-paste)))

(require 'shell-pop)
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(shell-pop-default-directory "/Users/kyagi/git")
 '(shell-pop-shell-type (quote ("multi-term" "*multi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
 '(shell-pop-term-shell "/bin/zsh")
 '(shell-pop-universal-key "C-c t")       ;ATALHO QUE EU VOU USAR (como nao sei se vou usar muito porque nao tem tab completion, entao fica nesse, C-t eh muito pessoal)
 '(shell-pop-window-size 30)
 '(shell-pop-full-span t)
 '(shell-pop-window-position "top"))
;; o pacote assim eh bao demais hein (poderia ter um para capturar ideias)
;; tipo um org capture
;; PRECISO VER: nao possui tab completion, pode ser um projeto
;; que para que eu traga um tab completion nesse term no emacs
#+END_SRC
**** Electric Pair: auto complete for 'pars chars'

#+BEGIN_SRC emacs-lisp
;; PACKAGE: eletric-pair.mode
;; Auto-complete of symbols like (), {}, []
(electric-pair-mode 1) ;; novo auto pair
;; make electric-pair-mode work on more brackets
(setq electric-pair-pairs '(
							(?\" . ?\")
							(?\{ . ?\})
							) )
#+END_SRC

**** Uniquify: unique buffer names
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

**** Abbrevs

#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name "~/.emacs.d/data/abbrev_defs") ;; database of abbrevs
(setq abbrev-mode t
	  save-abbrevs t)
(when (file-exists-p abbrev-file-name)
  (quietly-read-abbrev-file))
(add-hook 'kill-emacs-hook
		  'write-abbrev-file)
;; hippie-expand is as better version of dabbrev-expand.
;; While dabbrev-expand searches fo words you already types, in current;; buffers and others buffer , hippie-expands includes more sources.
;; such as filenames. kill ring...

(global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand

(setq
 hippie-expand-try-functions-list
 '(try-expand-dabbrev ;; try to expand word dynamically, searching the current buffer.
   try-expand-dabbrev-all-buffers ;; try to expand word dynamically, searching all other buffers
   try-expand-dabbrev-from-kill ;; try to expand word dynamically, searching the kill ring
   try-complete-file-name-partially ;; try to compelte text as a file name, as many characters as unique
   try-complete-file-name ;; tryu to complete text as file name.
   try-expand-all-abbrevs ;; try to expand word before point according ot all abbrev tables
   try-expand-list ;; try to coimplete the cuyrrent line to an entire line in the buffer
   try-expand-line ;; try to complete teh current line to an entire line in the buffer
   try-complete-lisp-symbol-partially ;; try to coimplete as an emacs lisp symbol,
   try-complete-lisp-symbol)
)

(require 'expand-region)
(global-key-binding (kbd "M-m") 'er/expand-region)
#+END_SRC

**** Undo Tree
#+BEGIN_SRC emacs-lisp
;; PACKAGE: undo-tree
;; visualize all the undo things done in a buffer in a tree view like
  (use-package undo-tree
	:ensure undo-tree
	:diminish undo-tree-mode
	:init
	(progn
	  (global-undo-tree-mode)
	  (setq undo-tree-visualizer-timestamps t)
	  (setq undo-tree-visualizer-diff t)))
#+END_SRC
**** Terminal Configuration

#+BEGIN_SRC emacs-lisp
(add-hook 'term-mode-hook       ;because of autopair
  #'(lambda () (setq autopair-dont-activate t)))
#+END_SRC
**** Dimish: less names in modeline
#+BEGIN_SRC emacs-lisp
(when (require 'diminish nil 'noerror)
  (eval-after-load "yas"
	'(diminish 'yas/minor-mode "yaS"))
  (eval-after-load "autopair"
	'(diminish 'autopair-mode "()")))
(eval-after-load 'simple
	'(progn
	   ;; diminish auto-fill-mode
	   (diminish 'auto-fill-function)
	   (diminish 'visual-line-mode)))
(when (require 'diminish nil 'noerror)
  (eval-after-load "company"
	  '(diminish 'company-mode "comp"))
  (eval-after-load "abbrev"
	'(diminish 'abbrev-mode "abbrv"))
 (eval-after-load "helm"
	'(diminish 'helm-mode "helm"))
 (eval-after-load "Irony"
	'(diminish 'irony-mode "iry"))
(add-hook 'emacs-lisp-mode-hook
  (lambda()
	(setq mode-name "el")))
(add-hook 'auto-fill-mode-hook
  (lambda()
	(setq mode-name "fill"))))
#+END_SRC
**** Highlight ()

#+BEGIN_SRC emacs-lisp
	 (add-hook 'highlight-parentheses-mode-hook
		  '(lambda ()
			 (setq autopair-handle-action-fns
				   (append
					(if autopair-handle-action-fns
						autopair-handle-action-fns
					  '(autopair-default-handle-action))
					'((lambda (action pair pos-before)
						(hl-paren-color-update)))))))

(define-globalized-minor-mode global-highlight-parentheses-mode
  highlight-parentheses-mode
  (lambda ()
	(highlight-parentheses-mode t))
  global-highlight-parentheses-mode t)
#+END_SRC

**** CTags
#+BEGIN_SRC emacs-lisp

 (setq path-to-ctags "/usr/bin/ctags"); <-- your ctags path here

  (defun create-tags (dir-name)
	 "Create tags file."
	 (interactive "DDirectory: ")
	 (eshell-command
	  (format "find %s -type f -name \"*.[ch]\" | etags -" dir-name)))

(defadvice find-tag (around refresh-etags activate)
   "Rerun etags and reload tags if tag not found and redo find-tag.
   If buffer is modified, ask about save before running etags."
  (let ((extension (file-name-extension (buffer-file-name))))
	(condition-case err
	ad-do-it
	  (error (and (buffer-modified-p)
		  (not (ding))
		  (y-or-n-p "Buffer is modified, save it? ")
		  (save-buffer))
		 (er-refresh-etags extension)
		 ad-do-it))))

  (defun er-refresh-etags (&optional extension)
  "Run etags on all peer files in current dir and reload them silently."
  (interactive)
  (shell-command (format "etags *.%s" (or extension "el")))
  (let ((tags-revert-without-query t))  ; don't query, revert silently
	(visit-tags-table default-directory nil)))
#+END_SRC

**** Visual Bookmarks using mouse

#+BEGIN_SRC emacs-lisp
;; PACKAGE: bm
;; visual bookmarks
(require 'bm)
;; um clica na margem (onde tem o número de linha) e bookmark aquela linha
;; utiliza o botão de rolagem do mouse para andar entre os bookmarks.
(global-set-key (kbd "<left-fringe> <mouse-5>") 'bm-next-mouse)
(global-set-key (kbd "<left-fringe> <mouse-4>") 'bm-previous-mouse)
(global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse)
#+END_SRC
**** Clipboard
#+BEGIN_SRC emacs-lisp
;; Save whatever’s in the current (system) clipboard before
;; replacing it with the Emacs’ text.
;; https://github.com/dakrone/eos/blob/master/eos.org
(setq save-interprogram-paste-before-kill t)
#+END_SRC
**** Desktop Save
	 saving the last frame/windows/buffers configurations
#+BEGIN_SRC emacs-lisp

;; from https://github.com/dakrone/eos/blob/master/eos-core.org
(desktop-save-mode 1)
(setq desktop-restore-eager 1)
(setq desktop-files-not-to-save "\\(^/[^/:]*:\\|(ftp)$\\|KILL\\)")
(setq desktop-restore-frames nil)
#+END_SRC
*** Editing file
**** Searching
#+BEGIN_SRC emacs-lisp
 (setq search-default-mode #'char-fold-to-regexp)
#+END_SRC
**** Align by whitespace
#+BEGIN_SRC emacs-lisp
(defun align-whitespace (start end)
  "Align columns by whitespace"
  (interactive "r")
  (align-regexp start end
				"\\(\\s-*\\)\\s-" 1 0 t))
#+END_SRC
**** Mark Ring
#+BEGIN_SRC emacs-lisp
(setq global-mark-ring-max 5000
	  mark-ring-max 5000
	  mode-require-final-newline t
	  )
#+END_SRC
**** Indentation e newline

#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux";; linux style baby
		c-basic-offset 4
		tab-width      4)
;;(global-set-key (kbd "RET") 'newline-and-indent)

;; PACKAGE: clean-indent-mode
;; remove tralling whitespace
(require 'clean-aindent-mode)
(add-hook 'prog-mode-hook 'clean-aindent-mode)

;; PACKAGE: dtrt-indent
;; maitain indentation for files
(require 'dtrt-indent)
(dtrt-indent-mode 1)
(setq dtrt-indent-verbosity 0)          ;turn off anoying message about identation

;; PACKAGE: ws-butler
(require 'ws-butler)
(add-hook 'c-mode-common-hook 'ws-butler-mode)

;; show unncessary whitespace that can mess up your diff
(add-hook 'prog-mode-hook
(lambda () (interactive) (setq show-trailing-whitespace 1)))

;; set appearance of a tab that is represented by 4 spaces
(setq-default tab-width 4)
(delete-selection-mode)
#+END_SRC
**** Kill ring
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 5000                     ;increase kill ring capacity
	  kill-whole-line t
	  )                     ;if NIL, kil lwhole line and ove the next line up
#+END_SRC

**** Defuns editing text files
#+BEGIN_SRC emacs-lisp
  (defcustom prelude-indent-sensitive-modes
    '(coffee-mode python-mode slim-mode haml-mode yalm-mode)
    "Modes for whith auto-indenting is suppressed."
    :type 'list)

  (defun indent-region-or-buffer ()
    "Indent a region if selected, otherwise the whole buffer."
    (interactive)
    (unless (member major-mode prelude-indent-sensitive-modes)
      (save-excursion
        (if (region-active-p)
            (progn
              (indent-region (region-beginning) (region-end))
              (message "Indented selected region"))
          (progn
            (indent-buffer)
            (message "Indented Buffer.")))
        (whitespace-cleanup))))

  (defun kill-default-buffer ()
    "Kill the currently active buffer -- set to C-x so that users are not asked which buffer they want to kill."
    (interactive)
    (let (kill-buffer-query-functions) (kill-buffer)))

  ;;smart openline
  (defun prelude-smart-open-line (arg)
    "Insert an empty line after the current line.
   Position the cursor at its beginning, according to the current mode
   With a prefix ARG open line above the current line."
    (interactive "P")
    (if arg
        (prelude-smart-open-line-above)
      (progn
        (move-end-of-line nil)
        (newline-and-indent))))

;; [#keybinding]
  (global-set-key (kbd "C-c i") 'indent-region-or-buffer)
  (global-set-key (kbd "C-x k") 'kill-default-buffer)
  (global-set-key (kbd "C-o") 'prelude-smart-open-line)

#+END_SRC

**** yank highlight :OFF:

#+BEGIN_SRC emacs-lisp
;; Package for when you yank (paste) something, the yanked (pasted) region will be highlighted
;;(require 'volatile-highlights)
;;(volatile-highlights-mode t)
#+END_SRC

**** Smart parens
#+BEGIN_SRC emacs-lisp
;; PACKAGE: smartparens-config
(require 'smartparens-config)
(setq sp-base-key-bindings 'paredit)
(setq sp-autoskip-closing-pair 'always)
(setq sp-hybrid-kill-entire-symbol nil)
(sp-use-smartparens-bindings)
(show-smartparens-global-mode +1)
(smartparens-global-mode 1)

;; whenr press RET, the curly braces automatically
;; add another newline
(sp-with-modes '(c-mode c++mode)
			   (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
			   (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
															 ("* ||\n[i]" "RET"))))



#+END_SRC

**** Revert Mode - para quando merda acontece
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC
**** Highlight current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC
**** Multiples cursors
#+BEGIN_SRC emacs-lisp
;; PACKAGE: multiple-cursors
(require 'multiple-cursors)
#+END_SRC
**** :OFF: Typing speed
	 :OFF: because it`s pretty lame `
#+BEGIN_SRC emacs-lisp
(require 'speed-type)
#+END_SRC
**** Markdown mode

#+BEGIN_SRC emacs-lisp
;; PACKAGE: markdown mode
(autoload 'markdown-mode "markdown-mode"
	   "Majoir ode for editing markdown files" t)
;; (add-to-list 'auto-mode-alist  '("\\.text\\'" . markdown-mode))
;; (add-to-list 'auto-mode-alist  '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist  '("\\.md\\'" . markdown-mode))
#+END_SRC
**** Ispell + Abbrev
#+BEGIN_SRC emacs-lisp
;; snippet found in: http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
	(save-excursion
	  (while (if (setq bef (endless/simple-get-word))
				 ;; Word was corrected or used quit.
				 (if (ispell-word nil 'quiet)
					 nil ; End the loop.
				   ;; Also end if we reach `bob'.
				   (not (bobp)))
			   ;; If there's no word at point, keep looking
			   ;; until `bob'.
			   (not (bobp)))
		(backward-word)
		(backward-char))
	  (setq aft (endless/simple-get-word)))
	(if (and aft bef (not (equal aft bef)))
		(let ((aft (downcase aft))
			  (bef (downcase bef)))
		  (define-abbrev
			(if p local-abbrev-table global-abbrev-table)
			bef aft)
		  (message "\"%s\" now expands to \"%s\" %sally"
				   bef aft (if p "loc" "glob")))
 (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)

#+END_SRC

**** Hungry Delete
     Delete space (no matter how much) with Ctrl+D
#+BEGIN_SRC emacs-lisp
(require 'hungry-delete)
(global-hungry-delete-mode)
#+END_SRC
**** :OFF: Beacon - find your damn cursor

	 :OFF: good idea but i never used
#+BEGIN_SRC emacs-lisp
;; this help alot in big monitors
(require 'beacon)
(setq beacon-push-mark 35)
(beacon-mode 1)
#+END_SRC

**** Fast searching with Swiper (helm backend)
#+BEGIN_SRC emacs-lisp
;; [#keybinding]
  (global-set-key "\C-r" 'swiper)
  (global-set-key "\C-s" 'swiper)
#+END_SRC
**** Creating parent directory
	 Function i found in
	 https://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
#+BEGIN_SRC emacs-lisp
(defun my-create-non-existent-directory ()
      (let ((parent-directory (file-name-directory buffer-file-name)))
        (when (and (not (file-exists-p parent-directory))
                   (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
          (make-directory parent-directory t))))
(add-to-list 'find-file-not-found-functions #'my-create-non-existent-directory)

#+END_SRC
*** Buffers
**** Scratch Buffer
#+BEGIN_SRC emacs-lisp
;; persistent-scratch, things i put in scratch buffer will remain to the ends of time
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))
#+END_SRC

*** Theming and visual configuration
#+BEGIN_SRC emacs-lisp
;; breadcrumb to help find bugs
(message "%s" "[init file]Setting emacs theming and fonts")
#+END_SRC
**** Fonts and smooth scroll
#+BEGIN_SRC emacs-lisp
(set-frame-font  "inconsolata-13")
;; scrolling to always be a line at a time
(setq scroll-conservatively 10000)
#+END_SRC
**** frame title and flymake highlight
#+BEGIN_SRC emacs-lisp
;; Frame Title Bar with full path of file
(setq-default
 frame-title-format
 (list '((buffer-file-name " %f" (dired-directory
				  dired-directory
				  (revert-buffer-function " %b"
							  ("%b - dir: " default-directory)))))))

;; cores que os erros do flymake vao aparecer
(custom-set-faces
 '(flymake-errline ((((class color)) (:underline "red"))))
 '(flymake-warnline ((((class color)) (:underline "yellow")))))
#+END_SRC
**** Font Lock for keywords

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
			   (lambda ()
				(font-lock-add-keywords nil
				 '(("\\<\\(FIXME\\|TODO\\|BUG\\|HACK\\|TIP\\|FUCKOFF\\):" 1
font-lock-warning-face t)))))

#+END_SRC

**** Colors/Theme, a lot of colors
#+BEGIN_SRC emacs-lisp
;; i really dont know why i doing this add-to-list again
(add-to-list 'custom-theme-load-path "/home/mvjunq/.emacs.d/elpa")
;(load-theme 'sanityinc-solarized-light t)
(load-theme 'spacemacs-dark t)
;; (load-theme solarized-light t)
;(load-theme 'base16-monokai-dark)
#+END_SRC

**** Set cursor color (i hate the default color on solarized)
#+BEGIN_SRC emacs-lisp
(set-cursor-color "#c75100")
#+END_SRC

*** Programming
**** C/C++
***** Compilação
#+BEGIN_SRC emacs-lisp
;; PACKAGE: compile
;; utiliza o makefile do diretório atual, caso não, cria um temporário
(require 'compile)
;; snippet found in http://endlessparentheses.com/better-compile-command.html
;; This gives a regular `compile-command' prompt.
(define-key prog-mode-map [C-f5] #'compile)

;; This just compiles immediately.
(define-key prog-mode-map [f5]
  #'endless/compile-please)
;; I'm not scared of saving everything.
(setq compilation-ask-about-save nil)
;; Stop on the first error.
(setq compilation-scroll-output 'next-error)
;; Don't stop on info or warnings.
(setq compilation-skip-threshold 2)

(defcustom endless/compile-window-size 105
  "Width given to the non-compilation window."
  :type 'integer
  :group 'endless)

(defun endless/compile-please (comint)
  "Compile without confirmation.
With a prefix argument, use comint-mode."
  (interactive "P")
  ;; Do the command without a prompt.
  (save-window-excursion
	(compile (eval compile-command) (and comint t)))
  ;; Create a compile window of the desired width.
  (pop-to-buffer (get-buffer "*compilation*"))
  (enlarge-window
   (- (frame-width)
	  endless/compile-window-size
	  (window-width))
   'horizontal))

(add-hook 'c-mode-hook
		   (lambda ()
		 (unless (file-exists-p "Makefile")
		   (set (make-local-variable 'compile-command)
					;; emulate make's .c.o implicit pattern rule, but with
					;; different defaults for the CC, CPPFLAGS, and CFLAGS
					;; variables:
					;; $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<
			(let ((file (file-name-nondirectory buffer-file-name)))
					  (format "%s -c -o %s.o %s %s %s"
							  (or (getenv "CC") "gcc")
							  (file-name-sans-extension file)
							  (or (getenv "CPPFLAGS") "-DDEBUG=9")
							  (or (getenv "CFLAGS") "-ansi -pedantic -Wall -g")
				  file))))))


#+END_SRC
***** ggtags
	  ggtags, best sistema de tags
#+BEGIN_SRC emacs-lisp
;; dired vai mostrar as tags
	  (add-hook 'dired-mode-hook 'ggtags-mode)
	  (add-hook 'c-mode-common-hook
	  (lambda ()
	  (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
	  (ggtags-mode 1))))
#+END_SRC

***** GDB - gnu debugger, (quase best) debugger (oi slime)
#+BEGIN_SRC emacs-lisp
;; gdb-many-windows (múltiplas janelas ao usar o gdb)
(setq
 gdb-many-windows t
 gdb-show-main t                        ;non-nil means display souce file containing the main routine ate startup
 )
#+END_SRC
***** Irony Mode - backend para autocomplete
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)
;; replace the `completion-at-point' and `complete-symbol' bindings in
;; irony-mode's buffers by irony-mode's function
(defun my-irony-mode-hook ()
  (define-key irony-mode-map [remap completion-at-point]
	'irony-completion-at-point-async)
  (define-key irony-mode-map [remap complete-symbol]
	'irony-completion-at-point-async))
(add-hook 'irony-mode-hook 'my-irony-mode-hook)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
(eval-after-load 'company
  '(add-to-list 'company-backends 'company-irony))
;; (optional) adds CC special commands to 'company-begin-commands' in order to
;; trigger completion at interest places, such as after scope operator
(add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
(add-hook 'irony-mode-hook 'irony-eldoc)
#+END_SRC
****** Defuns

#+BEGIN_SRC emacs-lisp
;; (optional) bind TAB for indent or complete
(defun irony--check-expastion()
  (save-excursion
	(if (looking-at- "\\_>") t
	  (backward-char 1)
	  (if (looking-at "\\.") t
	(backward-char 1)
	(if (looking-at "->") t nil)))))

(defun irony--indent-or-complete ()
  (interactive)
  (cond ((and (not (use-region-p))
		  (irony--check-expastion))
	 (message "complete")
	 (company-complete-common))
	(t
	 (message "indent")
	 (call-interactively 'c-indent-line-or-region))))
(defun irony-mode-keys ()
  "modify keymaps used by irony-mode"

  (local-set-key (kbd "TAB") 'irony--ident-or-complete)
  (local-set-key [tab] 'irony--indent-or-complete))
(add-hook 'c-mode-common-hook 'irony-mode-keys)

;; company-quick-help (mostra ajuda em indle)
(company-quickhelp-mode 1)      ;

#+END_SRC
***** Eldoc - helpdoce no bufferline
#+BEGIN_SRC emacs-lisp
;;(setq c-eldoc-includes "`pkg-config gtk+-2.0 --cflags``-I./ -I../' ")
(add-to-list 'load-path "elpa/c-eldoc")
(add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
#+END_SRC
***** :OFF: company-c-headers (auto complete para cabeçalhos)

#+BEGIN_SRC emacs-lisp
;;(add-to-list 'company-backends 'company-c-headers)
;;(add-to-list 'company-c-headers-path-user "/usr/lib/gcc/x86_64-unknown-linux-gnu/5.3.0/../../../../include/c++/5.3.0")
;;(add-to-list 'company-c-headers-path-userm "/usr/include/")
;;(add-to-list 'company-c-headers-path-user "/usr/include/c++")
#+END_SRC

***** :OFF: Helm-dash
	  Dash do mac sabe? Agora no emacs
	  obs:não funciona por algum motivo referente a instalação
#+BEGIN_SRC emacs-lisp
;;  (use-package helm-dash
;;   :ensure t
;;   :bind (("C-c D" . helm-dash))
;;   :init
;;   (setq helm-dash-common-docsets '("ElasticSearch")
;;         helm-dash-min-length 2)
;;   :config
;;   (defun eos/use-java-docset ()
;;     (setq-local helm-dash-docsets '("Java")))
;;   (defun eos/use-elisp-docset ()
;;     (setq-local helm-dash-docsets '("Emacs Lisp")))
;;   (add-hook 'java-mode-hook #'eos/use-java-docset)
;;  (add-hook 'emacs-lisp-mode-hook #'eos/use-elisp-docset))


#+END_SRC
***** Auto Complete com backend do irony+company
#+BEGIN_SRC emacs-lisp
;; (optional) adds CC special commands to `company-begin-commands' in order to
;; trigger completion at interesting places, such as after scope operator
;;     std::|
(add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
(eval-after-load 'company
  '(add-to-list 'company-backends 'company-irony))
#+END_SRC

***** Flycheck+irony
#+BEGIN_SRC emacs-lisp
(eval-after-load 'flycheck
  '(add-to-list 'flycheck-checkers 'irony))
#+END_SRC

***** Semantic mode

#+BEGIN_SRC emacs-lisp
;; PACKAGE: sematic (deja-vu?)
;; adiciona algumas libs para termos um contexto semântico
(require 'semantic)
(global-semanticdb-minor-mode 1)
(global-semantic-idle-scheduler-mode 1)
;; add new load path
(semantic-add-system-include "/usr/local/include")
(semantic-add-system-include "~/linux/include")
(global-semantic-idle-summary-mode 1) ;; show functions args in minibuffer
(global-semantic-stickyfunc-mode 1) ;; show in the top of file the funcion you are in
(semantic-add-system-include "~/linux/kernel")
(semantic-add-system-include "~/linux/include")
(semantic-mode 1)
#+END_SRC
***** :OFF: Functions args (tooptip for include headers in /usr/include)
#+BEGIN_SRC emacs-lisp
;;(fa-config-default)
;;(add-to-list 'company-backends '(company-irony company-yasnippet))
;;(define-key c-mode-map  [(contrl tab)] 'moo-complete)
;;(define-key c++-mode-map  [(control tab)] 'moo-complete)
;;(define-key c-mode-map (kbd "M-o")  'fa-show)
;;(define-key c++-mode-map (kbd "M-o")  'fa-show)
#+END_SRC
***** Hooks
#+BEGIN_SRC emacs-lisp
;; por alguma razão, preciso configurar isto denovo para prog-mode
(add-hook 'prog-mode-hook
			   (lambda ()
				(font-lock-add-keywords nil
				 '(("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 font-lock-warning-face t)))))
#+END_SRC
**** Emacs Lisp
***** eldoc e rainbow delimiters (cores para delimitadoresx)
#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: eldoc
  ;; helpdoc in minibuffer line
  (use-package "eldoc"
    :commands turn-on-eldoc-mode
    :init
    (progn
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
  ;; rainbow delimiters:
  ;; PACKAGE: rainbow-delimiters: syntax highlight para ()
  (require 'rainbow-delimiters)
  (add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'elisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'after-init-hook 'global-company-mode)
  (add-hook 'org-mode 'rainbow-delimiters-mode)
#+END_SRC
***** Pulando e procurando código
	  <C-c .> = find-function-at-point
	  <C-c f> = find-function
#+BEGIN_SRC emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
(bind-key "C-c f" 'find-function)
#+END_SRC
**** Python
#+BEGIN_SRC emacs-lisp
(package-initialize)
(elpy-enable)

;; JEDI

(use-package jedi
  :ensure t
  :init
  (add-hook 'python-mode-hook 'jedi:setup)
  (add-hook 'python-mode-hook 'jedi:ac-setup))
(setq jedi:complete-on-dot t)
;; for jedi backend
(add-to-list 'company-backends 'company-jedi)
(add-to-list 'company-backends '(company-jedi company-files))

;;flycheck with elpy, not flymake
(when (require 'flycheck nil t)
	(setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
	(add-hook 'elpy-mode-hook 'flycheck-mode))

;; pep8
(require 'py-autopep8)
(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)

#+END_SRC

**** Haskell
#+BEGIN_SRC emacs-lisp
(setq haskell-font-lock-symbols t)
;; still searching for the ideal haskell mode
;; (add-hook 'haskell-mode-hook 'haskell-doc-mode)
;; (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
;; (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
;; (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)
;; (add-hook 'haskell-mode-hook #'hindent-mode)
;; using cabal, stack for another time
;; (setq haskell-process-type 'stack-ghci)
;; (setq haskell-process-path-ghci "stack")
;; (setq haskell-process-args-ghci "ghci")
;; (autoload 'ghc-init "ghc" nil t)
;; (autoload 'ghc-debug "ghc" nil t)
;; (add-hook 'haskell-mode-hook (lambda () (ghc-init)))
;; (require 'flycheck)
;; (require 'flycheck-haskell)
;; (add-hook 'haskell-mode-hook 'flycheck-mode)
;; (add-hook 'flycheck-mode-hook 'flycheck-haskell-configure)
;; (require 'company)
;; (require 'company-ghci)
;; (push 'company-ghci company-backends)
;; (add-hook 'haskell-mode-hook 'company-mode)
#+END_SRC

***** Hasktags
	  Use the M-. luke11
#+BEGIN_SRC emacs-lisp
(let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
  (setenv "PATH" (concat my-cabal-path path-separator (getenv "PATH")))
  (add-to-list 'exec-path my-cabal-path))
(custom-set-variables '(haskell-tags-on-save t))
#+END_SRC

***** Indentation
#+BEGIN_SRC emacs-lisp
;;(add-to-list 'load-path "home/mvjunq/.emacs.d/lisp/misc/structured-haskell-mode/elisp/")
;;(require 'shm)
;;(add-hook 'haskell-mode-hook #'structured-haskell-mode)
#+END_SRC
***** Cabal REPL
#+BEGIN_SRC emacs-lisp
(custom-set-variables '(haskell-process-type 'cabal-repl))
#+END_SRC

***** Keybiddings
#+BEGIN_SRC emacs-lisp

;; Haskell compilation mode
(eval-after-load 'haskell-mode
  '(define-key haskell-mode-map (kbd "C-c C-o") 'haskell-compile))
(eval-after-load 'haskell-cabal
 '(define-key haskell-cabal-mode-map (kbd "C-c C-o") 'haskell-compile))
(custom-set-variables
  '(haskell-process-suggest-remove-import-lines t)
  '(haskell-process-auto-import-loaded-modules t)
  '(haskell-process-log t))
(eval-after-load 'haskell-mode '(progn
  (define-key haskell-mode-maps (kbd "C-c C-l") 'haskell-process-load-or-reload)
  (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
  (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
  (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
  (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
  (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
(eval-after-load 'haskell-cabal '(progn
  (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
  (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
  (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
  (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))
#+END_SRC

***** GHC-mod
#+BEGIN_SRC emacs-lisp

(let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
  (setenv "PATH" (concat my-cabal-path ":" (getenv "PATH")))
  (add-to-list 'exec-path my-cabal-path))
#+END_SRC

**** Aggressive Indent - WARNING: really agressive

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
;;(add-hook 'clojure-mode-hook #'aggressive-indent-mode)
;;(add-hook 'ruby-mode-hook #'aggressive-indent-mode)
;;(add-hook 'cc'-mode-hook #'aggressive-indent-mode)

#+END_SRC

**** Zeal ta no ponto (Y)

	 Open Zeal with the thing at point obs: DONT WORK, just open zeal
	 (still cool btw)
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cd" 'zeal-at-point)
#+END_SRC
**** Yasnippet

#+begin_src emacs-lisp
;; PACKAGE: yasnippet
;; yet another snippet mode
(yas-global-mode 1)
#+END_SRC
**** Fycheck

	 Flycheck - syntax checking on background
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'global-flycheck-mode)
;; using tooltip
(eval-after-load 'flycheck
  '(custom-set-variables
   '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))
(add-hook 'c-mode-hook 'flycheck-mode)
(add-hook 'c++-mode-hook 'flycheck-mode)
(eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
(setq flycheck-check-syntax-automatically '(mode-enabled save))
#+END_SRC
****** Flycheck e helm (eu odeio tooltips)

#+BEGIN_SRC emacs-lisp
(require 'helm-flycheck) ;; Not necessary if using ELPA package
(eval-after-load 'flycheck
  '(define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck))
#+END_SRC

**** Company Mode: autocomplete on steroids
#+BEGIN_SRC emacs-lisp
;; PACKAGE: company-mode
;; auto complete feature
(require 'company)
(require 'cc-mode)
(add-hook 'after-init-hook 'global-company-mode)
(setq company-backends (delete 'company-semantic company-backends))
(define-key c-mode-map  [(tab)] 'company-complete)
(define-key c++-mode-map  [(tab)] 'company-complete)
;;(add-to-list 'company-c-headers-path-user "/usr/include/c++") ;eu posso colocar mais include aqui neh?:git
#+END_SRC

***** Default Colors


	  *Código abaixo não faz sentido em não funcionar*

	  (require 'color)
	  (let ((bg (face-attribute 'default :background)))
	  (custom-set-faces
	  `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
	  `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 10)))))
	  `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 5)))))
	  `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
	  `(company-tooltip-common ((t (:inherit font-lock-constant-face))))))

**** Semantic Mode

	 Code completion baseada no buffer atual
#+BEGIN_SRC emacs-lisp
;; PACKAGE: semantic and cc-mode
(require 'cc-mode)
(require 'semantic)
(global-semanticdb-minor-mode 1)
(global-semantic-idle-scheduler-mode 1)
;; mostra a função em que estamos em cima da tela
(add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
;; adicionando mais paths para completion do semantic mode
;; para toda biblioteca que eu quiser ter semantic, eu adiciono aqui
(semantic-add-system-include "/usr/include/boost" 'c++-mode)
;; (semantic-add-system-include "~linux/include") ;nao tenho esse diretorio
(semantic-add-system-include "/usr/local/include") ;aqui ficaria os includes da máquina local
(semantic-add-system-include "/usr/include") ;vou colocar o include (mesmo sabendo que ele está por padrão)
#+END_SRC

**** Whitespace
#+begin-src emacs-lisp
	 (add-hook 'prog-mode-hook (lambda () (interactive) (setq
	 show-trailing-whitespace 1)))
	 ;;active whitespace mode to view all whitespace characters

	 (global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC
**** Tab para autocomplete
#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

**** :OFF: Counsel-Dash
#+BEGIN_SRC emacs-lisp
;;; PACKAGE: counsel-dash
;;; see dash docsets with counsel (helm)
;;;(require 'counsel-dash)
#+END_SRC

**** :OFF: Projectile
#+BEGIN_SRC emacs-lisp
;;(projectile-global-mode)
;;(setq projectile-enable-caching t)
#+END_SRC

*** Hooks
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace) ;; remove the dreadful trailing whitespace
(add-hook 'text-mode-hook 'turn-on-auto-fill) ;; text mode = best place for auto fill mode
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

*** Keybindings and navigation
**** Font size
#+BEGIN_SRC emacs-lisp
(bind-key "C-+" 'text-scale-increase)
(bind-key "C--" 'text-scale-decrease)
#+END_SRC
**** Speedbar
#+BEGIN_SRC emacs-lisp
(add-hook 'speedbar--reconfigure-keymaps-hook
	  '(lambda ()
		 (define-key speedbar-key-map (kbd "<up>") 'speedbar-prev)
		 (define-key speedbar-key-map (kbd "<down>") 'speedbar-next)
		 (define-key speedbar-key-map (kbd "<right>") 'speedbar-expand-line)
		 (define-key speedbar-key-map (kbd "<left>" ) 'speedbar-contract-line)
		 (define-key speedbar-key-map (kbd "M-<up>" ) 'speedbar-up-directory)
		 (define-key speedbar-key-map (kbd "<f5>") 'speedbar-refresh)))
	 (setq speedbar-show-unknown-files t)
#+END_SRC
**** Move to

#+BEGIN_SRC emacs-lisp
(defun sacha/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
	(let ((line-move-visual nil))
	  (forward-line (1- arg))))

  (let ((orig-point (point)))
	(back-to-indentation))
	(when (= orig-point (point))
	  (move-beginning-of-line 1)))

;; remap) C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
				'sacha/smarter-move-beginning-of-line)
#+END_SRC

**** fast navigation with <C+Shift+_>

#+BEGIN_SRC emacs-lisp
;; KEYBINDINGS :TODO: move to a better place (file??)
 ;; Move more quickly
(global-set-key (kbd "C-S-n")
				(lambda ()
				  (interactive)
				  (ignore-errors (next-line 5))))

(global-set-key (kbd "C-S-p")
				(lambda ()
				  (interactive)
				  (ignore-errors (previous-line 5))))

(global-set-key (kbd "C-S-f")
				(lambda ()
				  (interactive)
				  (ignore-errors (forward-char 5))))

(global-set-key (kbd "C-S-b")
				(lambda ()
				  (interactive)
				  (ignore-errors (backward-char 5))))
#+END_SRC
**** Pop to mark
	 from: Sasha.org config file
	 Handy way of getting back to previous places.
	 #+BEGIN_SRC emacs-lisp
	 (bind-key "C-x p" 'pop-to-mark-command)
	 (setq set-mark-command-repeat-pop t)
	 #+END_SRC
**** Which Key mode

	 Show commands after a certain key is used
#+BEGIN_SRC emacs-lisp
;;PACKAGE: which-key mode
(which-key-mode)
#+END_SRC
**** Help - guide key

	 from: sasha.org config file
 #+BEGIN_SRC emacs-lisp
 (use-package guide-key
  :diminish guide-key-mode
  :init
  (progn
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)))  ; Enable guide-key-mode
 #+END_SRC

**** visible bookmarks (F2)
#+BEGIN_SRC emacs-lisp
(use-package bm
  :bind (("<C-f2>" . bm-toggle)
         ("<f2>" . bm-next)
         ("<S-f2>" . bm-previous)))
#+END_SRC
**** :OFF: Avy, fast navigation by char

#+BEGIN_SRC emacs-lisp
;;(global-set-key (kbd "C-c j") 'avy-goto-word-or-subword-1)
;;(global-set-key (kbd "s-.") 'avy-goto-word-or-subword-1)
;;(global-set-key (kbd "s-w") 'ace-window)
#+END_SRC
**** :OFF: Outline Mode (HS)

#+BEGIN_SRC emacs-lisp
;;(global-set-key (kbd "C-c f") 'hs-hid-eblock)
;;(global-set-key (kbd "C-c s") 'hs-show-block)
;;(global-set-key (kbd "C-c a") 'hs-toggle-hiding)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x <up>") 'windmove-up)
(global-set-key (kbd "C-x <down>") 'windmove-down)
(global-set-key (kbd "C-x <right>") 'windmove-right)
(global-set-key (kbd "C-x <left>") 'windmove-left)
#+END_SRC
*** Org-mode
**** Babel things
#+BEGIN_SRC emacs-lisp
  ;; for org-babel and source code
  (setq org-confirm-babel-evaluate nil
      org-src-fontify-natively t
      org-src-tab-acts-natively t)
#+END_SRC
*** Defuns

	Functions i found in the interwebs (sorry for not having the
	source url).
#+BEGIN_SRC emacs-lisp
;; funcao parte da mensagem de erro no minibuffer
(defun my-flymake-show-help ()
   (when (get-char-property (point) 'flymake-overlay)
	 (let ((help (get-char-property (point) 'help-echo)))
	   (if help (message "%s" help)))))

;; indent in whitespace (interative action)
(defun indent-whitespace (beg end spaces)
  "Indent region of code by N spaces"
  (interactive "r\nnEnter number of spaces: \n")
  (indent-code-rigidly beg end spaces))

;; insert date, but <C-c .> is nice
(defun insert-date ()
  "insert date at point"
  (interactive)
  (insert (format-time-string "%a %Y-%m-%d - %l:%M %p")))

;; for the old time sakes
(defun ascii-table ()
  "Print the ascii table. Based on a defun by Alex Schroeder <asc@bsiag.com>"
  (interactive)
  (switch-to-buffer "*ASCII*")
  (erase-buffer)
  (insert (format "ASCII characters up to number %d.\n" 254))
  (let ((i 0))
	(while (< i 254)
	  (setq i (+ i 1))
	  (insert (format "%4d %c\n" i i))))
  (beginning-of-buffer))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)

  (condition-case nil
	  (prin1 (eval (read (current-kill 0)))
			 (current-buffer))
	(error (message "Invalid expression")
		   (insert (current-kill 0)))))

;; edit files like sudo
(defun sudo-edit (&optional arg)
  "do sudo things"
  (interactive "p")
  (if (or arg (not buffer-file-name))
	  (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
	(find-alternate-file (concat "/sudo:root@localhost": buffer-file-name))))

(defun increase-font-size ()
  (interactive)
  (set-face-attribute 'default
					  nil
					  :height
					  (ceiling (* 1.10
								  (face-attribute 'default :height)))))
(defun decrease-font-size ()
  (interactive)
  (set-face-attribute 'default
					  nil
					  :height
					  (floor (* 0.9
								(face-attribute 'default :height)))))

;;
;; slick copy
;;

(defadvice kill-ring-save (before slick-copy activate compile)
	  "When called interactively with no active region, copy a single line instead."
	  (interactive
	   (if mark-active (list (region-beginning) (region-end))
		 (message "Copied line")
		 (list (line-beginning-position)
			   (line-beginning-position 2)))))
	(defadvice kill-region (before slick-cut activate compile)
	  "When called interactively with no active region, kill a single line instead."
	  (interactive
	   (if mark-active (list (region-beginning) (region-end))
		 (list (line-beginning-position)
			   (line-beginning-position 2)))))
#+END_SRC

*** Emacs Debugging

#+BEGIN_SRC emacs-lisp
;; configure trace on init file errors
(setq edebug-trace t)

;; byte compile init files
(defun byte-compile-init-dir ()
  "Byte-compile all your dotfiles."
  (interactive)
  (byte-recompile-directory user-emacs-directory 0))
(defun remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
			(lambda ()
			  (if (file-exists-p (concat buffer-file-name "c"))
				  (delete-file (concat buffer-file-name "c"))))
			nil
			t))
(add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)


(defun indent-whole-buffer ()
  "indent whole buffer"
  (interactive)
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max) nil)
  (untabify (point-min) (point-max)))

;; eval buffer (init file)
;; found on interwebs
(with-eval-after-load 'debug
  (defun debugger-setup-buffer (debugger-args)
	"Initialize the `*Backtrace*' buffer for entry to the debugger.
That buffer should be current already."
	(setq buffer-read-only nil)
	(erase-buffer)
	(set-buffer-multibyte t)        ;Why was it nil ?  -stef
	(setq buffer-undo-list t)
	(let ((standard-output (current-buffer))
		  (print-escape-newlines t)
		  (print-level 8)
		  (print-length 50))
	  (backtrace))
	(goto-char (point-min))
	(delete-region (point)
				   (progn
					 (search-forward "\n  debug(")
					 (forward-line (if (eq (car debugger-args) 'debug)
									   2    ; Remove implement-debug-on-entry frame.
									 1))
					 (point)))
	(insert "Debugger entered")
	;; lambda is for debug-on-call when a function call is next.
	;; debug is for debug-on-entry function called.
	(pcase (car debugger-args)
	  ((or `lambda `debug)
	   (insert "--entering a function:\n"))
	  ;; Exiting a function.
	  (`exit
	   (insert "--returning value: ")
	   (setq debugger-value (nth 1 debugger-args))
	   (prin1 debugger-value (current-buffer))
	   (insert ?\n)
	   (delete-char 1)
	   (insert ? )
	   (beginning-of-line))
	  ;; Debugger entered for an error.
	  (`error
	   (insert "--Lisp error: ")
	   (prin1 (nth 1 debugger-args) (current-buffer))
	   (insert ?\n))
	  ;; debug-on-call, when the next thing is an eval.
	  (`t
	   (insert "--beginning evaluation of function call form:\n"))
	  ;; User calls debug directly.
	  (_
	   (insert ": ")
	   (prin1 (if (eq (car debugger-args) 'nil)
				  (cdr debugger-args) debugger-args)
			  (current-buffer))
	   (insert ?\n)))
	;; After any frame that uses eval-buffer,
	;; insert a line that states the buffer position it's reading at.
	(save-excursion
	  (let ((tem eval-buffer-list))
		(while (and tem
					(re-search-forward "^  eval-\\(buffer\\|region\\)(" nil t))
		  (beginning-of-line)
		  (insert (format "Error at line %d in %s: "
						  (with-current-buffer (car tem)
							(line-number-at-pos (point)))
						  (with-current-buffer (car tem)
							(buffer-name))))
		  (pop tem))))
	(debugger-make-xrefs)))

;; test config file without leaving emacs
;; found on interwebs
(defun test-emacs ()
  (interactive)
  (require 'async)
  (async-start
   (lambda () (shell-command-to-string
		  "emacs --batch --eval \"
(condition-case e
	(progn
	  (load \\\"~/.emacs\\\")
	  (message \\\"-OK-\\\"))
  (error
   (message \\\"ERROR!\\\")
   (signal (car e) (cdr e))))\""))
   `(lambda (output)
	  (if (string-match "-OK-" output)
		  (when ,(called-interactively-p 'any)
			(message "All is well"))
		(switch-to-buffer-other-window "*startup error*")
		(delete-region (point-min) (point-max))
		(insert output)
		(search-backward "ERROR!")))))
#+END_SRC
